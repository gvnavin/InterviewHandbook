[{"question":"main() {\u003cbr/\u003echar s[]\u003d\"man\";\u003cbr/\u003eint i; for(i\u003d0;s[i];i++)\u003cbr/\u003eprintf(\"%c%c%c%c\\s[i],*(s+i),*(i+s),i[s]); \u003cbr/\u003e}","answers":["Man","mmmm aaaa nnnn","Nnnn aaaa Mmmm","Man Man Man"],"correct_answer":1,"explanation":"s[i], *(i+s), *(s+i), i[s] are all different ways of expressing the same idea. Generally array name is the base address for that array. Here s is the base address. i is the index number/displacement from the base address. So, indirecting it with * is same as s[i]. i[s] may be surprising. But in the case of C it is same as s[i].\""},{"question":"main() {\u003cbr/\u003efloat me \u003d 1.1;\u003cbr/\u003edouble you \u003d 1.1;\u003cbr/\u003eif(me\u003d\u003dyou)\u003cbr/\u003eprintf(\"I love U\");\u003cbr/\u003eelse\u003cbr/\u003eprintf(\"I hate U\");\u003cbr/\u003e}","answers":["I love U","I hate U","Garbage value","Compiler Error"],"correct_answer":1,"explanation":"For floating point numbers (float, double, long double) the values cannot be predicted exactly. Depending on the number of bytes, the precession with of the value represented varies. Float takes 4 bytes and long double takes 10 bytes. So float stores 0.9 with less precision than long double.\""},{"question":"main() {\u003cbr/\u003eint static var \u003d 5;\u003cbr/\u003eprintf(\"%d \",var--);\u003cbr/\u003eif(var) main();\u003cbr/\u003e}","answers":["Compiler Error","1 2 3 4 5","Infinite loop","5 4 3 2 1"],"correct_answer":3,"explanation":"When static storage class is given, it is initialized once. The change in the value of a static variable is retained even between the function calls. Main is also treated like any other ordinary function, which can be called recursively.\""},{"question":"main() {\u003cbr/\u003ec[ ]\u003d{2.8,3.4,4,6.7,5};\u003cbr/\u003eint j,*p\u003dc,*q\u003dc;\u003cbr/\u003efor(j\u003d0;j\u003c5;j++) {\u003cbr/\u003eprintf(\" %d \",*c);\u003cbr/\u003e++q;\u003cbr/\u003e}","answers":["2.8  3.4  4  6.7","2  8  3  4  4  6  7","2  2  2  2  2  2  3  4  6  5 ","2  2  2  2  2  2  3  4  6  5  6 7"],"correct_answer":2,"explanation":"Initially pointer c is assigned to both p and q. In the first loop, since only q is incremented and not c , the value 2 will be printed 5 times. In second loop pitself is incremented. So the values 2 3 4 6 5 will be printed."},{"question":"main() {\u003cbr/\u003eextern int i;\u003cbr/\u003ei\u003d20;\u003cbr/\u003eprintf(\"%d\",i);\u003cbr/\u003e} ","answers":["20","Error : undefined reference to `i\u0027","Garbage Value","Infinite loop"],"correct_answer":1,"explanation":"extern storage class in the following declaration, extern int i; specifies to the compiler that the memory for i is allocated in some other program and that address will be given to the current program at the time of linking. But linker finds that no other variable of name iis available in any other program with memory space allocated for it. Hence a linker error has occured ."},{"question":"main() {\u003cbr/\u003eint i\u003d-1,j\u003d-1,k\u003d0,l\u003d2,m;\u003cbr/\u003em\u003di++\u0026\u0026j++\u0026\u0026k++||l++;\u003cbr/\u003eprintf(\"%d %d %d %d %d\",i,j,k,l,m);\u003cbr/\u003e} ","answers":["2 2 1 3 1","1 1 0 2 0","0 0 1 3 1","0 0 1 3 0"],"correct_answer":2,"explanation":"Logical operations always give a result of 1 or 0 . And also the logical AND (\u0026\u0026) operator has higher priority over the logical OR (||) operator. So the expression ‘i++ \u0026\u0026 j++ \u0026\u0026 k++’ is executed first. The result of this expression is 0 (-1 \u0026\u0026 -1 \u0026\u0026 0 \u003d 0). Now the expression is 0 || 2 which evaluates to 1 (because OR operator always gives 1 except for ‘0 || 0’ combination- for which it gives 0). So the value of m is 1. The values of other variables are also incremented by 1.\""},{"question":"main() {\u003cbr/\u003eprintf(\"%x\",-1\u003c\u003c4);\u003cbr/\u003e} ","answers":["10","fffffffe","fffffff0","ffffffe0"],"correct_answer":2,"explanation":" -1 is internally represented as all 1\u0027s. When left shifted four times the least significant 4 bits are filled with 0\u0027s.The %x format specifier specifies that the integer value be printed as a hexadecimal value.\""},{"question":"main() {\u003cbr/\u003eint i\u003d10;\u003cbr/\u003ei\u003d!i\u003e14;\u003cbr/\u003eprintf(\"i\u003d%d\",i);\u003cbr/\u003e} ","answers":["i\u003d0","i\u003d10","i\u003d 1","Error"],"correct_answer":0,"explanation":"In the expression !i\u003e14 , NOT (!) operator has more precedence than \u0027\u003e\u0027 symbol. !is a unary logical operator. !i (!10) is 0 (not of true is false). 0\u003e14 is false (zero)."},{"question":"main() {\u003cbr/\u003echar s[]\u003d{\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027\\n\u0027,\u0027c\u0027,\u0027\\0\u0027};\u003cbr/\u003echar *p,*str,*str1;\u003cbr/\u003ep\u003d\u0026s[3];\u003cbr/\u003estr\u003dp;\u003cbr/\u003estr1\u003ds;\u003cbr/\u003eprintf(\"%d\",++*p + ++*str1-32);\u003cbr/\u003e}","answers":["10","11","98","77"],"correct_answer":3,"explanation":"p is pointing to character \u0027\\n\u0027. str1 is pointing to character \u0027a\u0027 ++*p. \"pispointingto\u0027\\n\u0027andthatisincrementedbyone.\" the ASCII value of \u0027\\n\u0027 is 10, which is then incremented to 11. The value of ++*p is 11. ++*str1, str1 is pointing to \u0027a\u0027 that is incremented by 1 and it becomes \u0027b\u0027. ASCII value of \u0027b\u0027 is 98.\""},{"question":"#define square(x) x*x \u003cbr/\u003emain() {\u003cbr/\u003eint i;\u003cbr/\u003ei \u003d 64/square(4);\u003cbr/\u003eprintf(\"%d\",i);\u003cbr/\u003e}","answers":["4","64","16","0"],"correct_answer":1,"explanation":"the macro call square(4) will substituted by 4*4 so the expression becomes i \u003d 64/4*4 . Since / and * has equal priority the expression will be evaluated as (64/4)*4 i.e. 16*4 \u003d 64"},{"question":"main() {\u003cbr/\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void *v;\u003cbr/\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int integer\u003d2;\u003cbr/\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int *i\u003d\u0026integer;\u003cbr/\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;v\u003di;\u003cbr/\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;printf(\"%d\",(int*)*v);\u003cbr/\u003e} ","answers":["2","null","Runtime Error","Compiler Error"],"correct_answer":3,"explanation":"Void pointer is a generic pointer type. No pointer arithmetic can be done on it. Void pointers are normally used for, \u003cbr/\u003e1. Passing generic pointers to functions nd returning such pointers.\u003cbr/\u003e2. As a intermediate pointer type.\u003cbr/\u003e3. Used when the exact pointer type will be known at a later point of time."},{"question":"main() {\u003cbr/\u003estatic int i;\u003cbr/\u003e i++;\u003cbr/\u003e static int j;\u003cbr/\u003e j++;\u003cbr/\u003e static int k;\u003cbr/\u003e k++;\u003cbr/\u003e printf(\"i\u003d%d j\u003d%d k\u003d%d\",i,j,k);\u003cbr/\u003e}","answers":["i\u003d0 j\u003d0 k\u003d0","i\u003d1 j\u003d1 k\u003d1","GarbageValues","RuntimeError"],"correct_answer":1,"explanation":"Since static variables are initialized to zero by default"},{"question":"main() {\u003cbr/\u003eint n \u003d 10;\u003cbr/\u003ewhile(1) {\u003cbr/\u003e     if(printf(\"%d\",printf(\"%d \", n)))\u003cbr/\u003e         break;\u003cbr/\u003e     else\u003cbr/\u003e          continue;\u003cbr/\u003e     }\u003cbr/\u003e}","answers":["Infinite Loop","10 3","3 10","10 2"],"correct_answer":1,"explanation":"The inner printf executes first to print 10 and space. The printf returns no of characters printed and this value\u003d3. Still the outer printf prints 10 and space and so returns a non-zero value. So it encounters the break statement and comes out of the while statement"},{"question":"main() {\u003cbr/\u003eunsigned int i\u003d2;\u003cbr/\u003e while(i--\u003e\u003d0)printf(\"%u \",i);\u003cbr/\u003e}","answers":["2 1 0","InfiniteLoop","RuntimeError","0 1 2"],"correct_answer":1,"explanation":"The value of y%2 is 0. This value is assigned to x. The condition reduces to if (x) or in other words if(0) and so z goes uninitialized. Thumb Rule: Check all control paths to write bug free code."},{"question":"#define prod(a,b) a*b\u003cbr/\u003e main() {\u003cbr/\u003eint x\u003d3,y\u003d4;\u003cbr/\u003e printf(\"%d\",prod(x+2,y-1));\u003cbr/\u003e } ","answers":["9","10","11","12"],"correct_answer":1,"explanation":"The macro expands and evaluates to as: x+2*y-1 \u003d\u003e x+(2*y)-1 \u003d\u003e 10 "},{"question":"main() {\u003cbr/\u003eint i\u003d2;\u003cbr/\u003e while(i++!\u003d3);\u003cbr/\u003e printf(\"%d \",i);\u003cbr/\u003e } ","answers":["1 ","2 3","3 4","4"],"correct_answer":3,"explanation":"Note the semicolon after the while statement.  i\u003d2, it is not equal to  becomes 3, it increments 3 !\u003d 3 is false but i increments to 4, comes out out of while loop. This is due to post-increment on i, the value of i while printing is 4. "},{"question":"main() {\u003cbr/\u003eint i\u003d0;\u003cbr/\u003e while(+(+i--)!\u003d0) i-\u003di++;\u003cbr/\u003eprintf(\"%d\",i);\u003cbr/\u003e}","answers":["0","1","-1","-2"],"correct_answer":2,"explanation":"Unary + is the only dummy operator in C. So it has no effect on the expression and now the while loop is, while(i--!\u003d0) which is false and so breaks out of while loop. The value –1 is printed due to the post-decrement operator."},{"question":"main() {\u003cbr/\u003eunsigned char i\u003d0;\u003cbr/\u003e for(;i\u003e\u003d0;i++);\u003cbr/\u003e printf(\"%d\\n\",i);\u003cbr/\u003e}","answers":["-128","-127","128","Infinite Loop"],"correct_answer":3,"explanation":"unsigned char will always be greater than 0."},{"question":"main() {\u003cbr/\u003echar i\u003d0;\u003cbr/\u003e for(;i\u003e\u003d0;i++);\u003cbr/\u003e printf(\"%d\\n\",i);\u003cbr/\u003e}","answers":["-128","-127","128","Infinite Loop"],"correct_answer":0,"explanation":"Notice the semicolon at the end of the for loop. THe initial value of the i is set to 0. The inner loop executes to increment the value from 0 to 127 (the positive range of char) and then it rotates to the negative value of -128. The condition in the for loop fails and so comes out of the for loop. It prints the current value of i that is -128."},{"question":"Find what does int (*x)[10] mean?","answers":["x is a array of 10 integer pointers.","x is a pointer to array of(size 10) integers.","x is a array of 10 integers","Wrong declaration"],"correct_answer":1,"explanation":"Apply left to right rule to find the meaning of this definition."},{"question":"#ifdef something\u003cbr/\u003eint some\u003d0;\u003cbr/\u003e#endif\u003cbr/\u003emain() {\u003cbr/\u003eint thing \u003d 0;\u003cbr/\u003eprintf(\"%d %d\\n\", some ,thing);\u003cbr/\u003e} ","answers":["Compiler Error","Runtime Error","0 0","garbage Values"],"correct_answer":0,"explanation":"This is a very simple example for conditional compilation. The name something is not already known to the compiler making the declaration int some \u003d 0; "},{"question":"#if something \u003d\u003d 0\u003cbr/\u003eint some\u003d0;\u003cbr/\u003e#endif\u003cbr/\u003emain() {\u003cbr/\u003eint thing \u003d 0;\u003cbr/\u003eprintf(\"%d %d\\n\", some ,thing);\u003cbr/\u003e} ","answers":["Compiler Error","Runtime Error","0 0","garbage Values"],"correct_answer":2,"explanation":"This code is to show that preprocessor expressions are not the same as the ordinary expressions. If a name is not known the preprocessor treats it to be equal to zero."},{"question":"main() {\u003cbr/\u003eint arr2D[3][3];\u003cbr/\u003eprintf(\"%d\\n\", ((arr2D\u003d\u003d* arr2D)\u0026\u0026(* arr2D \u003d\u003d arr2D[0])) );\u003cbr/\u003e}","answers":["1","0","GarbageValue","RuntimeError"],"correct_answer":0,"explanation":"This is due to the close relation between the arrays and pointers. N dimensional arrays are made up of (N-1) dimensional arrays. arr2D is made up of a 3 single arrays that contains 3 integers each.The name arr2D refers to the beginning of all the 3 arrays. *arr2D refers to the start of the first 1D array (of 3 integers) that is the same address as arr2D. So the expression (arr2D \u003d\u003d *arr2D) is true (1). Similarly, *arr2D is nothing but *(arr2D + 0), adding a zero doesn\u0027t change the value/meaning. Again arr2D[0] is the another way of telling *(arr2D + 0). So the expression (*(arr2D + 0) \u003d\u003d arr2D[0]) is true (1). Since both parts of the expression evaluates to true the result is true(1) and the same is printed."},{"question":"main() {\u003cbr/\u003eif(~0 \u003d\u003d (unsigned int)-1)\u003cbr/\u003eprintf(\"Hi\");\u003cbr/\u003eelse\u003cbr/\u003e\tprintf(\"Hello\");\u003cbr/\u003e}","answers":["Hi","Hello","CompilerError","RuntimeError"],"correct_answer":0,"explanation":"~ (tilde operator or bit-wise negation operator) operates on 0 to produce all ones to fill the space for an integer. –1 is represented in unsigned value as all 1\u0027s and so both are equal."},{"question":"int swap(int *a,int *b) {\u003cbr/\u003e*a\u003d*a+*b;*b\u003d*a-*b;*a\u003d*a-*b;\u003cbr/\u003e}\u003cbr/\u003emain() {\u003cbr/\u003eint x\u003d10,y\u003d20;\u003cbr/\u003eswap(\u0026x,\u0026y);\u003cbr/\u003eprintf(\"x\u003d %d y \u003d %d\\n\",x,y);\u003cbr/\u003e}","answers":["GarbageValue","RuntimeError","x \u003d 10 y \u003d 20","x \u003d 20 y \u003d 10"],"correct_answer":3,"explanation":"This is one way of swapping two values. Simple checking will help understand this."},{"question":"main() {\u003cbr/\u003echar *p \u003d \"ayqm\";\u003cbr/\u003eprintf(\"%c\",++*(p++));}","answers":["a","y ","b","c"],"correct_answer":2,"explanation":"*(p) points to a, ++*(p) - pre-increments the value of a to b, then prints b. Then post-increments the p address to point to y."},{"question":"main() {\u003cbr/\u003eint i\u003d5;\u003cbr/\u003eprintf(\"%d\",++i++);\u003cbr/\u003e}","answers":["5","6","CompilerError","RuntimeError"],"correct_answer":2,"explanation":"Compiler error: Lvalue required in function main. ++i yields an rvalue.  For postfix ++ to operate an lvalue is required."},{"question":"int aaa() {\u003cbr/\u003eprintf(\"hi\");\u003cbr/\u003e}\u003cbr/\u003eint bbb() {\u003cbr/\u003eprintf(\"hello\");\u003cbr/\u003e} \u003cbr/\u003eint ccc(){\u003cbr/\u003eprintf(\"bye\");\u003cbr/\u003e}\u003cbr/\u003emain() {\u003cbr/\u003eint (*ptr[3])();\u003cbr/\u003eptr[0] \u003d aaa;\u003cbr/\u003eptr[1] \u003d bbb;\u003cbr/\u003eptr[2] \u003dccc;\u003cbr/\u003eptr[2]();\u003cbr/\u003e}","answers":["hi","hello","bye","CompilerError"],"correct_answer":2,"explanation":"int (* ptr[3])() says that ptr is an array of pointers to functions that takes no arguments and returns the type int. By the assignment ptr[0] \u003d aaa; it means that the first function pointer in the array is initialized with the address of the function aaa. Similarly, the other two array elements also get initialized with the addresses of the functions bbb and ccc. Since ptr[2] contains the address of the function ccc, the call to the function ptr[2]() is same as calling ccc(). So it results in printing \"bye\"."},{"question":"main() {\u003cbr/\u003eint i\u003d5;\u003cbr/\u003eprintf(\"%d\",i\u003d++i\u003d\u003d6);\u003cbr/\u003e}","answers":["5","6","0","1"],"correct_answer":3,"explanation":"The expression can be treated as i \u003d (++i\u003d\u003d6), because \u003d\u003d is of higher precedence than \u003d operator. In the inner expression, ++i is equal to 6 yielding true(1). Hence the result."},{"question":"main() {\u003cbr/\u003echar p[]\u003d\"%d\\n\";\u003cbr/\u003ep[1] \u003d \u0027c\u0027;\u003cbr/\u003eprintf(p,65);\u003cbr/\u003e}","answers":["65","A","B","c"],"correct_answer":1,"explanation":"Due to the assignment p[1] \u003d \"c\" the string becomes, \"%c\\n\". Since this string becomes the format string for printf and ASCII value of 65 is \u0027A\u0027, the same gets printed."},{"question":"main() {\u003cbr/\u003ewhile (strcmp(\"some\",\"some\\0\"))\u003cbr/\u003eprintf(\"Strings are not equal\\n\");\u003cbr/\u003e} ","answers":["Strings are not equal","No output","InfiniteLoop","RuntimeError"],"correct_answer":1,"explanation":"Ending the string constant with \\0 explicitly makes no difference. So “some” and “some\\0” are equivalent. So, strcmp returns 0 (false) hence breaking out of the while loop."},{"question":"main() {\u003cbr/\u003echar str1[] \u003d {\u0027s\u0027,\u0027o\u0027,\u0027m\u0027,\u0027e\u0027};\u003cbr/\u003echar str2[] \u003d {\u0027s\u0027,\u0027o\u0027,\u0027m\u0027,\u0027e\u0027,\u0027\\0\u0027};\u003cbr/\u003ewhile (strcmp(str1,str2)\u003d\u003d0)\u003cbr/\u003eprintf(\"Strings are not equal\\n\");\u003cbr/\u003e} ","answers":["Strings are not equal","No output","Infinite Loop","RuntimeError"],"correct_answer":1,"explanation":"If a string constant is initialized explicitly with characters, \u0027\\0\u0027 is not appended automatically to the string. Since str1 doesn\u0027t have null termination, it treats whatever the values that are in the following positions as part of the string until it randomly reaches a \u0027\\0\u0027. So str1 and str2 are not the same, hence the result."},{"question":"main() {\u003cbr/\u003eint i \u003d 3;\u003cbr/\u003efor (;i++\u003d0;)\u003cbr/\u003eprintf(\"%d\",i);}","answers":["RuntimeError","CompilerError","4","0"],"correct_answer":1,"explanation":"Compiler Error: Lvalue required. As we know that increment operators return rvalues and hence it cannot appear on the left hand side of an assignment operation."},{"question":"main() {\u003cbr/\u003eint i\u003d10,j\u003d20;\u003cbr/\u003ej \u003d i, j?(i,j)?i:j:j;\u003cbr/\u003eprintf(\"%d %d\",i,j);\u003cbr/\u003e}","answers":["10 10","20 20","10 20","20 10"],"correct_answer":0,"explanation":"The Ternary operator ( ? : ) is equivalent for if-then-else statement. So the question can be written as: if(i,j) {\u003cbr/\u003eif(i,j)\u003cbr/\u003ej \u003d i;\u003cbr/\u003eelse\u003cbr/\u003ej \u003d j;\u003cbr/\u003e}else\u003cbr/\u003ej \u003d j;\u003cbr/\u003e"},{"question":"main() {\u003cbr/\u003eint i\u003d5,j\u003d10;\u003cbr/\u003ei\u003di\u0026\u003dj\u0026\u002610;\u003cbr/\u003eprintf(\"%d %d\",i,j);\u003cbr/\u003e}","answers":["10 1","1 10","5 10","10 5"],"correct_answer":1,"explanation":"The expression can be written as i\u003d(i\u0026\u003d(j\u0026\u002610)); The inner expression (j\u0026\u002610) evaluates to 1 because j\u003d\u003d10. i is 5. i \u003d 5\u00261 is 1. Hence the result."},{"question":"main() {\u003cbr/\u003eint i\u003d4,j\u003d7;\u003cbr/\u003ej \u003d j || i++ \u0026\u0026 printf(\"YOU CAN\");\u003cbr/\u003eprintf(\"%d %d\", i, j);\u003cbr/\u003e}","answers":["5 7","7 5","1 5","4 1"],"correct_answer":3,"explanation":"The boolean expression needs to be evaluated only till the truth value of the expression is not known. j is not equal to zero itself means that the expression\u0027s truth value is 1. Because it is followed by || and true || (anything) \u003d\u003e true where (anything) will not be evaluated. So the remaining expression is not evaluated and so the value of i remains the same. Similarly when \u0026\u0026 operator is involved in an expression, when any of the operands become false, the whole expression\u0027s truth value becomes false and hence the remaining expression will not be evaluated. false \u0026\u0026 (anything) \u003d\u003e false where (anything) will not be evaluated."},{"question":"main() {\u003cbr/\u003eregister int a\u003d2;\u003cbr/\u003eprintf(\"Address of a \u003d %d\",\u0026a);\u003cbr/\u003e}","answers":["RuntimeError","CompilerError","2","GarbageValue"],"correct_answer":1,"explanation":"Compier Error: \u0027\u0026\u0027 on register variable. Rule to Remember : \u0026 (address of ) operator cannot be applied on register variables."},{"question":"main() {\u003cbr/\u003efloat i\u003d1.5;\u003cbr/\u003eswitch(i)\u003cbr/\u003e{\u003cbr/\u003ecase 1: printf(\"1\");\u003cbr/\u003ecase 2: printf(\"2\");\u003cbr/\u003edefault : printf(\"0\");\u003cbr/\u003e}\u003cbr/\u003e}","answers":["1","RuntimeError","CompilerError","GarbageValue"],"correct_answer":2,"explanation":"Compiler Error: switch expression not integral. Switch statements can be applied only to integral types."},{"question":"main() {\u003cbr/\u003eextern i;\u003cbr/\u003eprintf(\"%d\\n\",i);\u003cbr/\u003e{\u003cbr/\u003eint i\u003d20;\u003cbr/\u003eprintf(\"%d\\n\",i);\u003cbr/\u003e}\u003cbr/\u003e}","answers":["GarbageValue 20","20 20","RuntimeError","CompilerError"],"correct_answer":3,"explanation":"Linker Error : Unresolved external symbol i. The identifier i is available in the inner block and so using extern has no use in resolving it."},{"question":"main() {\u003cbr/\u003eint a\u003d2,*f1,*f2;\u003cbr/\u003ef1\u003df2\u003d\u0026a;\u003cbr/\u003e*f2+\u003d*f2+\u003da+\u003d2.5;\u003cbr/\u003eprintf(\"\\n%d %d %d\",a,*f1,*f2);\u003cbr/\u003e}","answers":["2 2 2","4 4 4 ","16 16 16","8 8 8"],"correct_answer":3,"explanation":"f1 and f2 both refer to the same memory location a. So changes through f1 and f2 ultimately affects only the value of a."},{"question":"main() {\u003cbr/\u003echar *p\u003d\"GOOD\";\u003cbr/\u003echar a[]\u003d\"GOOD\";\u003cbr/\u003eprintf(\"sizeof(p) \u003d %d, sizeof(*p) \u003d %d, strlen(p) \u003d %d\", sizeof(p), sizeof(*p), strlen(p));\u003cbr/\u003eprintf(\" sizeof(a) \u003d %d, strlen(a) \u003d %d\", sizeof(a), strlen(a));\u003cbr/\u003e}","answers":["sizeof(p) \u003d 2, sizeof(*p) \u003d 1, strlen(p) \u003d 4 sizeof(a) \u003d 4, strlen(a) \u003d 4","sizeof(p) \u003d 8, sizeof(*p) \u003d 1, strlen(p) \u003d 4 sizeof(a) \u003d 5, strlen(a) \u003d 4","sizeof(p) \u003d 2, sizeof(*p) \u003d 1, strlen(p) \u003d 4 sizeof(a) \u003d 5, strlen(a) \u003d 4","sizeof(p) \u003d 2, sizeof(*p) \u003d 4, strlen(p) \u003d 1 sizeof(a) \u003d 4, strlen(a) \u003d 2"],"correct_answer":1,"explanation":"When sizeof operator is applied to an array it returns the sizeof the array and it is not the same as the sizeof the pointer variable. Here the sizeof(a) where a is the character array and the size of the array is 5 because the space necessary for the terminating NULL character should also be taken into account."},{"question":"#define DIM(array, type) sizeof(array)/sizeof(type)\u003cbr/\u003emain() {\u003cbr/\u003eint arr[10];\u003cbr/\u003eprintf(\"The dimension of the array is %d\", DIM(arr, int));\u003cbr/\u003e}","answers":["10","80","40","20"],"correct_answer":0,"explanation":"The size of integer array of 10 elements is 10 * sizeof(int). The macro expands to sizeof(arr)/sizeof(int) \u003d\u003e 10 * sizeof(int) / sizeof(int) \u003d\u003e 10. "},{"question":"int DIM(int array[]) {\u003cbr/\u003ereturn sizeof(array)/sizeof(int);\u003cbr/\u003e}\u003cbr/\u003emain() {\u003cbr/\u003eint arr[10];\u003cbr/\u003eprintf(\"The dimension of the array is %d\", DIM(arr));\u003cbr/\u003e}","answers":["1","2","10","80"],"correct_answer":1,"explanation":"Arrays cannot be passed to functions as arguments and only the pointers can be passed. So the argument is equivalent to int * array (this is one of the very few places where [] and * usage are equivalent). The return statement becomes, sizeof(int *)/ sizeof(int) that happens to be equal in this case."},{"question":"main() {\u003cbr/\u003evoid swap();\u003cbr/\u003eint x\u003d10,y\u003d8;\u003cbr/\u003eswap(\u0026x,\u0026y);\u003cbr/\u003eprintf(\"x\u003d%d y\u003d%d\",x,y);\u003cbr/\u003e}\u003cbr/\u003evoid swap(int *a, int *b) {\u003cbr/\u003e*a ^\u003d *b, *b ^\u003d *a, *a ^\u003d *b;\u003cbr/\u003e}","answers":["x\u003d8 y\u003d10","x\u003d10 y\u003d8","x\u003d8 y\u003d6","x\u003d12 y\u003d10"],"correct_answer":0,"explanation":"This is a way to swap two variables without using a temporary variable and that too in a single statement."},{"question":"main() {\u003cbr/\u003eint i \u003d 257;\u003cbr/\u003eint *iPtr \u003d \u0026i;\u003cbr/\u003eprintf(\"%d %d\", *((char*)iPtr), *((char*)iPtr+1) );\u003cbr/\u003e}","answers":["257 257","1 1","1 257","257 1"],"correct_answer":1,"explanation":"The integer value 257 is stored in the memory as, 00000001 00000001, so the individual bytes are taken by casting it to char * and get printed."},{"question":"main() {\u003cbr/\u003eint i \u003d 258;\u003cbr/\u003eint *iPtr \u003d \u0026i;\u003cbr/\u003eprintf(\"%d %d\", *((char*)iPtr), *((char*)iPtr+1) );\u003cbr/\u003e}","answers":["1 1","1 2","2 1","2 2"],"correct_answer":2,"explanation":"The integer value 257 can be represented in binary as, 00000001 00000001. Remember that the INTEL machines are \u0027small-endian\u0027 machines. Small-endian means that the lower order bytes are stored in the higher memory addresses and the higher order bytes are stored in lower addresses. The integer value 258 is stored in memory as: 00000001 00000010."},{"question":"main() {\u003cbr/\u003eint i\u003d300;\u003cbr/\u003echar *ptr \u003d \u0026i;\u003cbr/\u003e*++ptr\u003d2; printf(\"%d\",i);\u003cbr/\u003e}","answers":["556","302","557","300"],"correct_answer":0,"explanation":"The integer value 300 in binary notation is: 00000001 00101100. It is stored in memory (small-endian) as: 00101100 00000001. Result of the expression *++ptr \u003d 2 makes the memory representation as: 00101100 00000010. So the integer corresponding to it is 00000010 00101100 \u003d\u003e 556."},{"question":"main() {\u003cbr/\u003echar * str \u003d \"hello\";\u003cbr/\u003echar * ptr \u003d str;\u003cbr/\u003echar least \u003d 127;\u003cbr/\u003ewhile (*ptr++)\u003cbr/\u003eleast \u003d (*ptr\u003cleast ) ? *ptr :least;\u003cbr/\u003eprintf(\"%d\",least);\u003cbr/\u003e} ","answers":["0","1","127","128"],"correct_answer":0,"explanation":"After \u0027ptr\u0027 reaches the end of the string the value pointed by \u0027str\u0027 is \u0027\\0\u0027. So the value of \u0027str\u0027 is less than that of \u0027least\u0027. So the value of \u0027least\u0027 finally is 0. "},{"question":"Is the following code legal?\u003cbr/\u003estruct a {\u003cbr/\u003eint x;struct a b;\u003cbr/\u003e}","answers":["yes","no","N/A","N/A"],"correct_answer":1,"explanation":"Is it not legal for a structure to contain a member that is of the same type as in this case. Because this will cause the structure declaration to be recursive without end."},{"question":"Is the following code legal?\u003cbr/\u003estruct a {\u003cbr/\u003eint x;\u003cbr/\u003estruct a *b;\u003cbr/\u003e} ","answers":["yes","no","N/A","N/A"],"correct_answer":0,"explanation":"*b is a pointer to type struct a and so is legal. The compiler knows, the size of the pointer to a structure even before the size of the structure is determined(as you know the pointer to any type is of same size). This type of structures is known as \u0027self-referencing\u0027 structure. "},{"question":"Is the following code legal?\u003cbr/\u003etypedef struct a {\u003cbr/\u003eint x;\u003cbr/\u003eaType *b;\u003cbr/\u003e}aType","answers":["yes","no","N/A","N/A"],"correct_answer":1,"explanation":"The typename aType is not known at the point of declaring the structure (forward references are not made for typedefs)."},{"question":"Is the following code legal?\u003cbr/\u003etypedef struct a aType;\u003cbr/\u003estruct a {\u003cbr/\u003eint x;\u003cbr/\u003eaType *b;\u003cbr/\u003e}; ","answers":["yes","no","N/A","N/A"],"correct_answer":0,"explanation":"The typename aType is known at the point of declaring the structure, because it is already typedefined."},{"question":"Is the following code legal?\u003cbr/\u003emain() {\u003cbr/\u003etypedef struct a aType;\u003cbr/\u003eaType someVariable;\u003cbr/\u003estruct a {\u003cbr/\u003eint x;\u003cbr/\u003eaType *b;\u003cbr/\u003e};\u003cbr/\u003e}","answers":["yes","no","N/A","N/A"],"correct_answer":1,"explanation":"When the declaration, typedef struct a aType; is encountered body of struct a is not known. This is known as \u0027incomplete types\u0027. "},{"question":"main() {\u003cbr/\u003eprintf(\"%d \", sizeof( void *));\u003cbr/\u003eprintf(\"%d \", sizeof(int *));\u003cbr/\u003eprintf(\"%d \", sizeof(double *));\u003cbr/\u003eprintf(\"%d \", sizeof(struct unknown *));\u003cbr/\u003e}","answers":["8 8 8 8","4 4 4 4","1 4 8 8","1 4 4 8"],"correct_answer":0,"explanation":"The pointer to any type is of same size."},{"question":"Is this code legal?\u003cbr/\u003eint *ptr;\u003cbr/\u003eptr \u003d (int *) 0x400;","answers":["yes","no","N/A","N/A"],"correct_answer":0,"explanation":"The pointer ptr will point at the integer in the memory location 0x400."},{"question":"#define a 10 \u003cbr/\u003emain() {\u003cbr/\u003e#define a 50 \u003cbr/\u003eprintf(\"%d\",a);\u003cbr/\u003e}","answers":["50 ","10","CompilerError","RuntimeError"],"correct_answer":0,"explanation":"The preprocessor directives can be redefined anywhere in the program. So the most recently assigned value will be taken."},{"question":"#define clrscr() 100 \u003cbr/\u003emain() {\u003cbr/\u003eclrscr(); \u003cbr/\u003eprintf(\"%d\\n\",clrscr()); \u003cbr/\u003e}","answers":["100","200","CompilerError","RuntimeError"],"correct_answer":0,"explanation":"Preprocessor executes as a seperate pass before the execution of the compiler. So textual replacement of clrscr() to 100 occurs.The input program to compiler looks like this\u003cbr/\u003emain() {\u003cbr/\u003e100;\u003cbr/\u003eprintf(\"%d\\n\",100);\u003cbr/\u003e}\u003cbr/\u003eNote: 100; is an executable statement but with no action. So it doesn\u0027t give any problem."},{"question":"main() { \u003cbr/\u003eprintf(\"%p\",main); \u003cbr/\u003e}","answers":["CompilerError","Some Address will be printed","RuntimeError","InfiniteLoop"],"correct_answer":1,"explanation":"Function  names  are  just  addresses  (just  like  array  names  are addresses). main() is also a function. So the address of function main will be printed. %p in printf specifies that the argument is an address. They are printed as hexadecimal numbers."},{"question":"enum colors {BLACK,BLUE,GREEN} \u003cbr/\u003emain() {\u003cbr/\u003eprintf(\"%d..%d..%d\",BLACK,BLUE,GREEN);\u003cbr/\u003e}","answers":["0..0..0","1..1..1","0..1..2","2..2..2"],"correct_answer":2,"explanation":"enum assigns numbers starting from 0, if not explicitly defined"},{"question":"main() { \u003cbr/\u003echar *p; p\u003d\"Hello\"; \u003cbr/\u003eprintf(\"%c\\n\",*\u0026*p); \u003cbr/\u003e}","answers":["H","e","l","o"],"correct_answer":0,"explanation":"* is a dereference operator \u0026 is a reference operator. They can be applied any number of times provided it is meaningful. Here p points to the first character in the string \"Hello\". *p dereferences it and so its value is H. Again \u0026 references it to an address and * dereferences it to the value H."},{"question":"main() {\u003cbr/\u003eint i\u003d5; \u003cbr/\u003eprintf(\"%d\",i++ + ++i);\u003cbr/\u003e}","answers":["10","11","12","13"],"correct_answer":2,"explanation":"First ++i run to increment the value from 5 to 6. i+i \u003d 6+6 \u003d 12. It prints then i++ will increment the value to 13."},{"question":"main() { \u003cbr/\u003eint i\u003d5; \u003cbr/\u003eprintf(\"%d\",i++ ++ +i); \u003cbr/\u003e} ","answers":["10","11","12","CompilerError"],"correct_answer":3,"explanation":"The expression i+++++i is parsed as i ++ ++ + i which is an illegal combination of operators."},{"question":"main() {\u003cbr/\u003eint i\u003d1,j\u003d2; \u003cbr/\u003eswitch(i) { \u003cbr/\u003ecase 1: printf(\"GOOD\"); break; \u003cbr/\u003ecase j: printf(\"BAD\"); break; \u003cbr/\u003e} \u003cbr/\u003e} ","answers":["CompilerError","RuntimeError","GOOD","BAD"],"correct_answer":0,"explanation":"Compiler Error: Constant expression required in function main. The case statement can have only constant expressions (this implies that we cannot use variable names directly so an error). Note: Enumerated types can be used in case statements."},{"question":"main() {\u003cbr/\u003eint i; \u003cbr/\u003eprintf(\"%d\",scanf(\"%d\",\u0026i)); // value 10 is given as input here \u003cbr/\u003e}","answers":["10","2","1","0"],"correct_answer":2,"explanation":"Scanf returns number of items successfully read and not 1/0. Here 10 is given as input which should have been scanned successfully. So number of items read is 1."},{"question":"#define f(g,g2) g##g2 \u003cbr/\u003emain() { \u003cbr/\u003eint var12\u003d100; \u003cbr/\u003eprintf(\"%d\",f(var,12)); \u003cbr/\u003e}","answers":["100","12","CompilerError","RuntimeError"],"correct_answer":0,"explanation":"f(var,12) will preprocessed to var12. var12 \u003d 100. ## will concatenate the variables."},{"question":"main() { \u003cbr/\u003eint i;\u003cbr/\u003efor(i\u003d0; i++; printf(\"%d\",i)); \u003cbr/\u003eprintf(\"%d\",i); \u003cbr/\u003e}","answers":["InfiniteLoop","CompilerError","RuntimeError","0"],"correct_answer":3,"explanation":"Before entering into the for loop the checking condition is \"evaluated\". Here it evaluates to 0 (false) and comes out of the loop, and i is incremented (note the semicolon after the for loop)."},{"question":"main() { \u003cbr/\u003eprintf(\"%d\", out); \u003cbr/\u003e} \u003cbr/\u003eint out\u003d100;","answers":["CompilerError","RuntimeError","100","0"],"correct_answer":0,"explanation":"The rule is that a variable is available for use from the point of declaration. Even though a is a global variable, it is not available for main. Hence an error. "},{"question":"main() { \u003cbr/\u003eextern out; \u003cbr/\u003eprintf(\"%d\", out); \u003cbr/\u003e}\u003cbr/\u003eint out\u003d100; ","answers":["CompilerError","RuntimeError","100","0"],"correct_answer":2,"explanation":"If you want to use global variable before initialization use extern, so it will get correctly initialized."},{"question":"main() {\u003cbr/\u003eint a[] \u003d {10,20,30,40,50},j,*p; \u003cbr/\u003efor(j\u003d0; j\u003c1; j++) { \u003cbr/\u003eprintf(\"%d\" ,*a); a++; \u003cbr/\u003e} \u003cbr/\u003e}","answers":["10","CompilerError","RuntimeError","100"],"correct_answer":1,"explanation":"Compiler error: lvalue required. Error is in line with statement a++. The operand must be an lvalue and may be of any of scalar type for the any operator, array name only when subscripted is an lvalue. Simply array name is a non-modifiable lvalue."},{"question":"main() { \u003cbr/\u003evoid *vp;\u003cbr/\u003echar ch \u003d \u0027g\u0027,*cp \u003d \"goofy\";\u003cbr/\u003eint j \u003d 20;\u003cbr/\u003evp \u003d \u0026ch;\u003cbr/\u003eprintf(\"%c\",*(char *)vp); \u003cbr/\u003evp \u003d \u0026j; \u003cbr/\u003eprintf(\"%d\",*(int *)vp); \u003cbr/\u003evp \u003d cp;\u003cbr/\u003eprintf(\"%s\",(char *)vp + 3);\u003cbr/\u003e}","answers":["20ofy","g0020","g20fy","g23fy"],"correct_answer":2,"explanation":"Since a void pointer is used it can be type casted to any other type pointer. vp \u003d \u0026ch stores address of char ch and the next statement prints the value stored in vp after type casting it to the proper data type pointer. the output is \u0027g\u0027. Similarly the output from second printf is \u002720\u0027. The third printf statement type casts it to print the string from the 4th value hence the output."},{"question":"main() { \u003cbr/\u003estatic char *s[ ] \u003d {\"black\", \"white\", \"yellow\", \"violet\"}; \u003cbr/\u003echar **ptr[ ] \u003d {s+3, s+2, s+1, s}, ***p; \u003cbr/\u003ep \u003d ptr; \u003cbr/\u003e**++p; \u003cbr/\u003eprintf(\"%s\",*--*++p + 3); \u003cbr/\u003e} ","answers":["wh","ye","ck","et"],"correct_answer":2,"explanation":"In this problem we have an array of char pointers pointing to start of 4 strings. Then we have ptr which is a pointer to a pointer of type char and a variable p which is a pointer to a pointer to a pointer of type char. p hold the initial value of ptr, i.e. p \u003d s+3. The next statement increment value in p by 1 , thus now value of p \u003d s+2. In the printf statement the expression is evaluated *++p causes gets value s+1 then the pre decrement is executed and we get s+1 – 1 \u003d s . the indirection operator now gets the value from the array of s and adds 3 to the starting address. The string is printed starting from this position. Thus, the output is ‘ck’."},{"question":"main() { \u003cbr/\u003echar *cptr,c; \u003cbr/\u003evoid *vptr,v; \u003cbr/\u003ec\u003d10; \u003cbr/\u003ev\u003d0; \u003cbr/\u003ecptr\u003d\u0026c; \u003cbr/\u003evptr\u003d\u0026v; \u003cbr/\u003eprintf(\"%c %v\",c,v); \u003cbr/\u003e}","answers":["10 0","10 10 ","RuntimeError","CompilerError"],"correct_answer":3,"explanation":"You can create a variable of type void * but not of type void, since void is an empty type. In the second line you are creating variable vptr of type void * and v of type void hence an error. "},{"question":"main() { \u003cbr/\u003echar *str1\u003d\"abcd\"; \u003cbr/\u003echar str2[]\u003d\"abcd\"; \u003cbr/\u003eprintf(\"%d %d %d\",sizeof(str1),sizeof(str2),sizeof(\"abcd\")); \u003cbr/\u003e}","answers":["2 5 5","4 5 5  ","8 5 5","16 5 5"],"correct_answer":2,"explanation":"In first sizeof, str1 is a character pointer so it gives you the size of the pointer variable. In second sizeof the name str2 indicates the name of the array whose size is 5 (including the \u0027\\0\u0027 termination character). The third sizeof is similar to the second one."},{"question":"main() { \u003cbr/\u003echar not; \u003cbr/\u003enot\u003d!2; \u003cbr/\u003eprintf(\"%d\",not);\u003cbr/\u003e}","answers":["0","1","2","3"],"correct_answer":0,"explanation":"! is a logical operator. In C the value 0 is considered to be the boolean value FALSE, and any non-zero value is considered to be the boolean value TRUE. Here 2 is a non-zero value so TRUE. !TRUE is FALSE. so it prints 0."},{"question":"#define FALSE -1 \u003cbr/\u003e#define TRUE 1 \u003cbr/\u003e#define NULL 0 \u003cbr/\u003emain() { \u003cbr/\u003eif(NULL) \u003cbr/\u003eputs(\"NULL\"); \u003cbr/\u003eelse if(FALSE) \u003cbr/\u003eputs(\"TRUE\"); \u003cbr/\u003eelse \u003cbr/\u003eputs(\"FALSE\"); \u003cbr/\u003e}","answers":["NULL ","TRUE","FALSE","CompilerError"],"correct_answer":1,"explanation":"Preprocessor doesn\u0027t replace the values given inside the double quotes. The check by if condition is boolean value false so it goes to else. In second if -1 is boolean value true hence \"TRUE\" is printed."},{"question":"main() { \u003cbr/\u003eint k\u003d1; \u003cbr/\u003eprintf(\"%d\u003d\u003d1 is \"\"%s\",k,k\u003d\u003d1?\"TRUE\":\"FALSE\"); \u003cbr/\u003e} ","answers":["CompilerError","RuntimeError","1\u003d\u003d1 is FALSE","1\u003d\u003d1 is TRUE"],"correct_answer":3,"explanation":"When two strings are placed together (or separated by white-space) they are concatenated (this is called as \"stringization\" operation). So the string is as if it is given as \"%d\u003d\u003d1 is %s\". The conditional operator( ?: ) evaluates to \"TRUE\"."},{"question":"main() {\u003cbr/\u003eint y \u003d 2000;\u003cbr/\u003eif( (y%4\u003d\u003d0 \u0026\u0026 y%100 !\u003d 0) || y%100 \u003d\u003d 0 ) \u003cbr/\u003eprintf(\"%d is a leap year\", y); \u003cbr/\u003eelse \u003cbr/\u003eprintf(\"%d is not a leap year\", y); \u003cbr/\u003e}","answers":["2000 is a leap year","2000 is not a leap year","N/A","N/A"],"correct_answer":0,"explanation":"An ordinary program to check given year is leap year or not. "},{"question":"int i\u003d10; \u003cbr/\u003emain() { \u003cbr/\u003eextern int i; \u003cbr/\u003e{ \u003cbr/\u003eint i\u003d20; \u003cbr/\u003e{\u003cbr/\u003econst volatile unsigned i\u003d30; printf(\"%d \",i);\u003cbr/\u003e}\u003cbr/\u003eprintf(\"%d \",i);\u003cbr/\u003e}\u003cbr/\u003eprintf(\"%d\",i);\u003cbr/\u003e}","answers":["10 20 30","30 20 10","20 10 30","30 10 20"],"correct_answer":1,"explanation":"\u0027{\u0027 introduces new block and thus new scope. In the innermost block i is declared as, const volatile unsignedwhich is a valid declaration. i is assumed of type int. So printf prints 30. In the next block, i has value 20 and so printf prints 20. In the outermost block, i is declared as extern, so no storage space is allocated for it. After compilation is over the linker resolves it to global variable i (since it is the only variable visible there). So it prints i\u0027s value as 10."},{"question":"main() {\u003cbr/\u003eint *j;\u003cbr/\u003e{\u003cbr/\u003eint i\u003d10; \u003cbr/\u003ej\u003d\u0026i; \u003cbr/\u003e} \u003cbr/\u003eprintf(\"%d\",*j); \u003cbr/\u003e}","answers":["10","GarbageValue","SomeAddress","RuntimeError"],"correct_answer":0,"explanation":"The variable i is a block level variable and the visibility is inside that block only. But the lifetime of i is lifetime of the function so it lives upto the exit of main function. Since the i is still allocated space, *j prints the value stored in i since j points i. "},{"question":"main() {\u003cbr/\u003echar a[]\u003d\"12345\\0\";\u003cbr/\u003eint i\u003dstrlen(a);\u003cbr/\u003eprintf(\"%d\\n\",++i);\u003cbr/\u003e}","answers":["4","5","6","7"],"correct_answer":2,"explanation":"The char array \u0027a\u0027 will hold the initialized string, whose length will be counted from 0 till the null character. Hence the \u0027I\u0027 will hold the value equal to 5, after the pre-increment in the printf statement, the 6 will be printed."},{"question":"main() {\u003cbr/\u003eint k\u003dret(sizeof(float)); \u003cbr/\u003eprintf(\"%d\",++k); \u003cbr/\u003e}\u003cbr/\u003eint ret(int ret) {\u003cbr/\u003eret +\u003d 2.5; return(ret);\u003cbr/\u003e}","answers":["5","6","7","8"],"correct_answer":2,"explanation":"The int ret(int ret), ie., the function name and the argument name can be the same. Firstly, the function ret() is called in which the sizeof(float) ie., 4 is passed, after the first expression the value in ret will be 6, as ret is integer hence the value stored in ret will have implicit type conversion from float to int. The ret is returned in main() it is printed after and preincrement."},{"question":"main() {\u003cbr/\u003eint i;\u003cbr/\u003echar a[]\u003d\"\\0\"; \u003cbr/\u003eif(printf(\"%s\\n\",a)) \u003cbr/\u003eprintf(\"Ok here \\n\"); \u003cbr/\u003eelse\u003cbr/\u003eprintf(\"Forget it\\n\");\u003cbr/\u003e}","answers":["Ok here","Forget it","N/A","N/A"],"correct_answer":0,"explanation":"printf will return how many characters does it print. Hence printing a null character returns 1 which makes the if statement true, thus \"Ok here\" is printed."}]